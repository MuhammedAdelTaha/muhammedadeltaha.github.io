<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Better Understanding of AI Search Algorithms · Mohamed Adel
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohamed Adel">
<meta name="description" content="In this article, we will discuss the different types of AI search algorithms, focusing on uninformed search algorithms. 
We will cover Depth-First Search (DFS), Breadth-First Search (BFS), Depth-Limited Search (DLS), Iterative Deepening DFS 
(ID-DFS), and Uniform Cost Search (UCS).
">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Better Understanding of AI Search Algorithms"/>
<meta name="twitter:description" content="In this article, we will discuss the different types of AI search algorithms, focusing on uninformed search algorithms. 
We will cover Depth-First Search (DFS), Breadth-First Search (BFS), Depth-Limited Search (DLS), Iterative Deepening DFS 
(ID-DFS), and Uniform Cost Search (UCS).
"/>

<meta property="og:title" content="Better Understanding of AI Search Algorithms" />
<meta property="og:description" content="In this article, we will discuss the different types of AI search algorithms, focusing on uninformed search algorithms. 
We will cover Depth-First Search (DFS), Breadth-First Search (BFS), Depth-Limited Search (DLS), Iterative Deepening DFS 
(ID-DFS), and Uniform Cost Search (UCS).
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://muhammedadeltaha.github.io/articles/better-understanding-of-ai-search-algorithms/" /><meta property="article:section" content="articles" />
<meta property="article:published_time" content="2024-02-02T23:53:51+02:00" />
<meta property="article:modified_time" content="2024-02-02T23:53:51+02:00" />





<link rel="canonical" href="https://muhammedadeltaha.github.io/articles/better-understanding-of-ai-search-algorithms/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css" integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Mohamed Adel
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/articles/">Articles</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/projects/">Projects</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://muhammedadeltaha.github.io/articles/better-understanding-of-ai-search-algorithms/">
              Better Understanding of AI Search Algorithms
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-02-02T23:53:51&#43;02:00">
                February 2, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              13-minute read
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/mohamed-adel/">Mohamed Adel</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/artificial-intelligence/">Artificial Intelligence</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ai/">AI</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/search-algorithms/">Search Algorithms</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/algorithms/">Algorithms</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/python/">Python</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        








<figure>
    
        <img src="background.jpeg" title="Created by the Author with Copilot" alt="Created by the Author with Copilot" width="100%"
             height="" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b></b> Created by the Author with Copilot</figcaption>
    
</figure>
<h1 id="table-of-contents">
  Table of Contents
  <a class="heading-link" href="#table-of-contents">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<ul>
<li><a href="#main-idea" >Main Idea</a></li>
<li><a href="#types-of-ai-search-algorithms" >Types of AI Search Algorithms</a></li>
<li><a href="#uninformed-search-algorithms" >Uninformed Search Algorithms</a>
<ul>
<li><a href="#depth-first-search-dfs" >Depth-First Search (DFS)</a></li>
<li><a href="#breadth-first-search-bfs" >Breadth-First Search (BFS)</a></li>
<li><a href="#depth-limited-search-dls" >Depth-Limited Search (DLS)</a></li>
<li><a href="#iterative-deepening-dfs-id-dfs" >Iterative Deepening DFS (ID-DFS)</a></li>
<li><a href="#uniform-cost-search-ucs" >Uniform Cost Search (UCS)</a></li>
</ul>
</li>
</ul>
<h2 id="main-idea">
  Main Idea
  <a class="heading-link" href="#main-idea">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Let us imagine that Engineers do not yet implement these kinds of algorithms,
and we have
to think about modeling a life problem into a graph that represents all the states that this problem could be in.
For sure, the solution to our problem is a state in this graph.</p>
<p>Let us also think about the different cases of our knowledge about these states.</p>
<ul>
<li>
<p><strong>Case one:</strong> that we already know the solution to our problem, and we just need to find a way to achieve this solution.</p>
</li>
<li>
<p><strong>Case two:</strong> that there could be multiple solutions to our problem that we don&rsquo;t know, but we have the ability to judge if the solution is correct or not.</p>
</li>
</ul>
<div class="notice note">
  <div class="notice-title">
    <i class="fa-solid fa-sticky-note" aria-hidden="true"></i>Note
  </div>
  <div class="notice-content">This is just a way of thinking about search techniques, not some theoretical perspective of AI search.</div>
</div>

<h2 id="types-of-ai-search-algorithms">
  Types of AI Search Algorithms
  <a class="heading-link" href="#types-of-ai-search-algorithms">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>From this way of thinking, we could divide our search techniques into two main categories:</p>
<ul>
<li><strong>Uninformed and Informed Search</strong></li>
<li><strong>Constraints Satisfaction Problems (CSPs)</strong></li>
</ul>
<p>In uninformed and informed searches, <strong>we know the goal</strong> we want to reach,
and we are looking for a <strong>path</strong> to achieve this goal from our current state.
In fact, we may not just look for any path.
Why not consider looking for the best path?
As an example, in 8-puzzle problem we know our goal state should be like in <strong>[Figure 1]</strong>.
We just need to find the path to this state from any given initial state.</p>









<figure>
    
        <img src="fig1.svg" title="Goal state in 8-puzzle problem" alt="Goal state in 8-puzzle problem" width="fit-content"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 1:</b> Goal state in 8-puzzle problem</figcaption>
    
</figure>
<p>In CSPs, we know some constraints that we can judge if the state we have reached is a valid goal state or not.
As an example, imagine you have a list of numbers that could be put next to each other at any order.
And then you have all possible arrangements that these numbers could be in.
But there are some constraints on these numbers like, for example,
that any 5 should be next to 4 and any 9 should not be next to 10.
Then you should look at these possibilities one by one, and on each possible arrangement of these numbers
you should check if it violates the constraints or not.
If it does not violate any constraints, then this could be one of the solutions.
Note that there could be many possibilities
that do not violate the constraints, therefore, there could be many solutions to this problem.</p>
<p>Another Famous Example of CSPs is the Map Coloring problem.
Given Australia&rsquo;s map, we need to color each region in a way that no two adjacent regions have the same color.
Suppose we have four colors, then we should color the map in a way that satisfies this constraint.
This is a CSP problem
because we have constraints that we should satisfy to reach a valid solution to color the map in <strong>[Figure 2]</strong>.</p>









<figure>
    
        <img src="fig2.png" title="Example of a CSP problem (Map Coloring)" alt="Example of a CSP problem (Map Coloring)" width="50%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 2:</b> Example of a CSP problem (Map Coloring)</figcaption>
    
</figure>
<p>Now we have a better understanding of how these algorithms should work. Let us summarize these words at several points:</p>
<ul>
<li><strong>State space:</strong> the list of states that the problem could be in</li>
<li><strong>Successor function:</strong> the successor states of the current state</li>
<li><strong>Initial state:</strong> the state where the problem initially in</li>
<li><strong>Goal state:</strong> the desired state</li>
<li><strong>path:</strong> the path from the initial state to the goal state</li>
</ul>
<p>In every algorithm, we will consider these points:</p>
<ul>
<li><strong>Completeness:</strong> is it guaranteed that the algorithm will find the solution?</li>
<li><strong>Optimality:</strong> will the algorithm find the optimal solution?</li>
<li><strong>Time complexity:</strong> how many nodes did the algorithm have to expand?</li>
<li><strong>Space complexity:</strong> required space for the algorithm to find the solution?</li>
</ul>
<p>In this story, we will focus on uninformed search algorithms.</p>
<h2 id="uninformed-search-algorithms">
  Uninformed Search Algorithms
  <a class="heading-link" href="#uninformed-search-algorithms">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>We have several algorithms under this search category. Every algorithm has its own pros and cons that we will discuss.</p>
<ul>
<li>Depth-First Search (DFS)</li>
<li>Breadth-First Search (BFS)</li>
<li>Depth-Limited Search (DLS)</li>
<li>Iterative Deepening DFS (ID-DFS)</li>
<li>Uniform Cost Search (UCS)</li>
</ul>
<p>What do we need to implement these algorithms?</p>
<ul>
<li><strong>Frontier (aka Fringe):</strong> we use this data structure to keep track of what to explore next. We may use Stack, Queue, or Priority Queue</li>
<li><strong>Closed Set:</strong> we use this data structure to keep track of what we already explored to avoid repetitive work</li>
<li><strong>Parents Directory:</strong> to keep track of every state&rsquo;s parent. We will use this directory to extract the path from the initial state to the goal state</li>
</ul>
<p>These Algorithms differ only in the successor function, which is the states to be explored next.
We use different data structures usually called fringe or frontier to control these exploration techniques.</p>
<h3 id="depth-first-search-dfs">
  Depth-First Search (DFS)
  <a class="heading-link" href="#depth-first-search-dfs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="overview">
  Overview
  <a class="heading-link" href="#overview">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In DFS, we explore nodes with the highest depth first like in <strong>[Figure 3]</strong>.</p>









<figure>
    
        <video src="fig3.mp4" controls title="DFS Visualization" width="90%"
               height="100%" style="float: none"></video>
    
    
        <figcaption style="font-size: 16px"><b>Figure 3:</b> DFS Visualization</figcaption>
    
</figure>
<h4 id="frontier">
  Frontier
  <a class="heading-link" href="#frontier">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>We choose the Stack data structure to be our frontier in DFS.</p>
<p><strong>The main idea of using Stack is:</strong></p>
<p>The state pushes its successor states in the stack
and takes the top of the Stack and pushes its successor states and so on until we reach a leaf node,
then we start to backtrack.
This ensures that we will explore nodes with the highest depth first.</p>
<div class="notice note">
  <div class="notice-title">
    <i class="fa-solid fa-sticky-note" aria-hidden="true"></i>Note
  </div>
  <div class="notice-content"><p><strong>Why do we need both Frontier and Closed Set?</strong></p>
<p>If the state is on the frontier, that does not mean that it has to be in the Closed Set and vice versa.
If the state is on the frontier, that means that this state will be explored soon.
If the state is in the Closed Set that means, it has already been explored, and we pushed all its successor states.</p></div>
</div>

<h4 id="implementation">
  Implementation
  <a class="heading-link" href="#implementation">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="n">initial_state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">parents</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>First, we initialize the frontier to contain only the initial state.
And the explored set to be empty.
And the parents&rsquo; directory contains the initial state as a parent to itself
(This will help us to know that this is the root of the tree).</p>
<p>Second, we start looping as long the frontier is not empty.
If there is no solution,
then we will explore the whole search tree until the frontier is empty without finding any solution.
In this case, we return None meaning that there is no solution.</p>
<p>Third,
if there is a solution, then we start popping the current state from the frontier and add it to the explored set
(to avoid repetitive work).
If it is the goal state, then we return the parents&rsquo; directory.
If not,
then we get its neighbors
and push them one by one into the frontier
after checking that this neighbor state is neither in the frontier nor in the explored set.</p>
<div class="notice note">
  <div class="notice-title">
    <i class="fa-solid fa-sticky-note" aria-hidden="true"></i>Note
  </div>
  <div class="notice-content">We check if the state is a goal state when we are popping it from the frontier.
Not when we are pushing it into the frontier.</div>
</div>

<h4 id="completeness">
  Completeness
  <a class="heading-link" href="#completeness">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>DFS is not complete because it may go deep into an infinite branch.</p>
<h4 id="optimality">
  Optimality
  <a class="heading-link" href="#optimality">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>DFS is not optimal because it finds the most left solution branch.
There could be better branches that lead to the solution than this branch.</p>
<h4 id="time-complexity">
  Time Complexity
  <a class="heading-link" href="#time-complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>If our search tree has a branching factor (b) and our solution is at depth (m).
The worst-case scenario will be that the goal state is the rightest leaf node in the search tree.
We will search the whole tree.
Then the time complexity will be the number of nodes in our search tree.</p>
<p>Number of expanded nodes = $1 + b + b^2 + b^3 + &hellip; + b^m$</p>
<p>Time complexity = Number of expanded nodes = $O(b^m)$</p>
<h4 id="space-complexity">
  Space Complexity
  <a class="heading-link" href="#space-complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In our frontier, we will store the successors
presented in the branch from the initial state to the goal state like in <strong>[Figure 4]</strong>.</p>
<p>We will store (b) nodes for (m) depth.</p>
<p>Space complexity = $O(b*m)$</p>









<figure>
    
        <img src="fig4.svg" title="Visualization of the nodes pushed into the frontier in DFS" alt="Visualization of the nodes pushed into the frontier in DFS" width="90%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 4:</b> Visualization of the nodes pushed into the frontier in DFS</figcaption>
    
</figure>
<h3 id="breadth-first-search-bfs">
  Breadth-First Search (BFS)
  <a class="heading-link" href="#breadth-first-search-bfs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="overview-1">
  Overview
  <a class="heading-link" href="#overview-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In BFS, we explore nodes with the shallowest depth first like in <strong>[Figure 5]</strong>.</p>









<figure>
    
        <video src="fig5.mp4" controls title="BFS Visualization" width="90%"
               height="100%" style="float: none"></video>
    
    
        <figcaption style="font-size: 16px"><b>Figure 5:</b> BFS Visualization</figcaption>
    
</figure>
<h4 id="frontier-1">
  Frontier
  <a class="heading-link" href="#frontier-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>We choose the Queue data structure to be our frontier in BFS.</p>
<p><strong>Main idea of using Queue is:</strong></p>
<p>The state pushes its successor states into the Queue
and takes the top of the Queue and pushes its successor states into
the Queue and so on until we reach a leaf node, then we start to backtrack.
This ensures that we will explore nodes with the shallowest depth first.</p>
<h4 id="implementation-1">
  Implementation
  <a class="heading-link" href="#implementation-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="n">initial_state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">parents</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>Same steps in DFS, but with a Queue data structure as our frontier.</p>
<h4 id="completeness-1">
  Completeness
  <a class="heading-link" href="#completeness-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>BFS is complete because it searches the tree level by level. So, it will not go in an infinite branch.</p>
<h4 id="optimality-1">
  Optimality
  <a class="heading-link" href="#optimality-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>BFS is optimal only if all branches have the same cost, because it finds the path with the least number of edges,
therefore, it will find the optimal path if all branches have the same cost.
Also, the cost of edges should be non-negative.</p>
<h4 id="time-complexity-1">
  Time Complexity
  <a class="heading-link" href="#time-complexity-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>If our search tree has a branching factor (b) and our solution is at depth (m).
The worst-case scenario will be that the goal state is the rightest leaf node in the search tree.
We will search the whole tree.
Then the time complexity will be the number of nodes in our search tree.</p>
<p>Number of expanded nodes = $1 + b + b^2 + b^3 + &hellip; + b^m$</p>
<p>Time complexity = Number of expanded nodes = $O(b^m)$</p>
<h4 id="space-complexity-1">
  Space Complexity
  <a class="heading-link" href="#space-complexity-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In our frontier, we will store at least all nodes in a level when exploring this level.
The worst-case scenario that our goal is a leaf node, so our frontier will contain all leaves like in <strong>[Figure 6]</strong>.</p>
<p>The number of leaves = $b^m$</p>
<p>Space complexity = $O(b^m)$</p>









<figure>
    
        <img src="fig6.svg" title="Visualization of the nodes pushed into the frontier in BFS" alt="Visualization of the nodes pushed into the frontier in BFS" width="90%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 6:</b> Visualization of the nodes pushed into the frontier in BFS</figcaption>
    
</figure>
<h3 id="depth-limited-search-dls">
  Depth-Limited Search (DLS)
  <a class="heading-link" href="#depth-limited-search-dls">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="overview-2">
  Overview
  <a class="heading-link" href="#overview-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In DLS, we explore nodes with the highest depth first like in <strong>[Figure 7]</strong>.
But the difference here that we explore until we reach a specific depth.</p>









<figure>
    
        <img src="fig7.gif" title="DLS Visualization" alt="DLS Visualization" width="90%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 7:</b> DLS Visualization</figcaption>
    
</figure>
<h4 id="frontier-2">
  Frontier
  <a class="heading-link" href="#frontier-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>We choose the Stack data structure to be our frontier in DLS like in DFS.</p>
<h4 id="implementation-2">
  Implementation
  <a class="heading-link" href="#implementation-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dls</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="n">initial_state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">initial_state</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">parents</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">neighbor</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>Same steps in DFS,
but we check if the depth reaches the specified max depth then we continue with other nodes in the fringe.</p>
<h4 id="completeness-2">
  Completeness
  <a class="heading-link" href="#completeness-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>DLS is not complete because it backtracks if it reaches a specified depth.
The goal state may lie in the next level like in <strong>[Figure 7]</strong>.</p>
<h4 id="optimality-2">
  Optimality
  <a class="heading-link" href="#optimality-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>DLS is not optimal for the same reasons in DFS.</p>
<h4 id="time-complexity-2">
  Time Complexity
  <a class="heading-link" href="#time-complexity-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Same as DFS, but with depth (d) (the maximum depth).</p>
<p>Time complexity = $O(b^d)$</p>
<h4 id="space-complexity-2">
  Space Complexity
  <a class="heading-link" href="#space-complexity-2">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Same as DFS, but with depth (d) (the maximum depth).</p>
<p>Space complexity = $O(b*d)$</p>
<h3 id="iterative-deepening-dfs-id-dfs">
  Iterative Deepening DFS (ID-DFS)
  <a class="heading-link" href="#iterative-deepening-dfs-id-dfs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="overview-3">
  Overview
  <a class="heading-link" href="#overview-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In ID-DFS we do DLS for max depth from 1 to m, where (m) is the depth at which the goal node lies.
Like in <strong>[Figure 8]</strong>.</p>









<figure>
    
        <img src="fig8.gif" title="ID-DFS Visualization" alt="ID-DFS Visualization" width="90%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 8:</b> ID-DFS Visualization</figcaption>
    
</figure>
<h4 id="frontier-3">
  Frontier
  <a class="heading-link" href="#frontier-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>We choose the Stack data structure to be our frontier in ID-DFS like in DFS and DLS.</p>
<h4 id="implementation-3">
  Implementation
  <a class="heading-link" href="#implementation-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dls</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="n">initial_state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">initial_state</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">parents</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">neighbor</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">iddfs</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">state</span> <span class="o">=</span> <span class="n">dls</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span>
</span></span></code></pre></div><p>We run DLS for d initially equals one and increment d by one until we find our goal state.</p>
<h4 id="completeness-3">
  Completeness
  <a class="heading-link" href="#completeness-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>ID-DFS is complete, it runs level by level until finding the goal state. In other words, it uses DFS and BFS together.</p>
<h4 id="optimality-3">
  Optimality
  <a class="heading-link" href="#optimality-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>ID-DFS is optimal, it runs level by level until finding the goal state,
so it will find the path with the least number of edges.
But like BFS, it is optimal only if all branches have the same cost.
Also, the cost of edges should be non-negative.</p>
<h4 id="time-complexity-3">
  Time Complexity
  <a class="heading-link" href="#time-complexity-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>The goal node lies at depth (m).
So, we will run DLS for (m) times.
Each time we will run DLS for a specific depth.
So, the time complexity will be the sum of the time complexity of DLS for each depth.</p>
<p>Time complexity = $O(b + b^2 + b^3 + &hellip; + b^m)$ = $O(b^m)$</p>
<h4 id="space-complexity-3">
  Space Complexity
  <a class="heading-link" href="#space-complexity-3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>The space complexity will be the space complexity of DLS for the maximum depth.</p>
<p>Space complexity = $O(b*m)$</p>
<h3 id="uniform-cost-search-ucs">
  Uniform Cost Search (UCS)
  <a class="heading-link" href="#uniform-cost-search-ucs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="overview-4">
  Overview
  <a class="heading-link" href="#overview-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>In UCS, we explore nodes with the least cost first like in <strong>[Figure 9]</strong>.</p>









<figure>
    
        <img src="fig9.gif" title="UCS Visualization" alt="UCS Visualization" width="70%"
             height="100%" style="float: none; border-radius: 10px;
             box-shadow: 0 0 15px 3px rgba(115,115,115,0.25); margin: 5px;">
    
    
        <figcaption style="font-size: 16px"><b>Figure 9:</b> UCS Visualization</figcaption>
    
</figure>
<h4 id="frontier-4">
  Frontier
  <a class="heading-link" href="#frontier-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>We choose the Priority Queue data structure to be our frontier in UCS.</p>
<p><strong>Main idea of using Priority Queue is:</strong></p>
<p>The state pushes its successor states into the Priority Queue
and takes the top of the Priority Queue and pushes its successor states into the Priority Queue
and so on until we reach a leaf node, then we start to backtrack.
This ensures that we will explore nodes with the least cost first.</p>
<h4 id="implementation-4">
  Implementation
  <a class="heading-link" href="#implementation-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ucs</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">parents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_state</span><span class="p">:</span> <span class="n">initial_state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">goal_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">parents</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parents</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">frontier</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">None</span>
</span></span></code></pre></div><p>Same steps, but with a Priority Queue data structure as our frontier.</p>
<h4 id="completeness-4">
  Completeness
  <a class="heading-link" href="#completeness-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>UCS is complete because it explores nodes with the least cost first. So, it will not go in an infinite branch.</p>
<h4 id="optimality-4">
  Optimality
  <a class="heading-link" href="#optimality-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>UCS is optimal
because it finds the path with the least cost even if the edges have different costs or there exist negative edges.</p>
<h4 id="time-complexity-4">
  Time Complexity
  <a class="heading-link" href="#time-complexity-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Processes all nodes with cost less than the cheapest solution.
If that solution costs C* and arcs cost at least $\epsilon$, then the <strong>effective depth</strong> is roughly $C^*/\epsilon$.</p>
<p>Time complexity = $O(b^{C^*/\epsilon})$</p>
<h4 id="space-complexity-4">
  Space Complexity
  <a class="heading-link" href="#space-complexity-4">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>The space complexity is the same as BFS. The space complexity will be the space complexity of BFS for the maximum depth.</p>
<p>Space complexity = $O(b^{C^*/\epsilon})$</p>

      </div>

      <footer>
        


        
        
        
        
        

        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Happy Coding in 2025 😊
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
